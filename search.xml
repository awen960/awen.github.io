<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>git总结</title>
      <link href="/2023/01/18/git-zong-jie/"/>
      <url>/2023/01/18/git-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="git的使用"><a href="#git的使用" class="headerlink" title="git的使用"></a>git的使用</h2><h3 id="1-git的安装"><a href="#1-git的安装" class="headerlink" title="1. git的安装"></a>1. git的安装</h3><ul><li><p><a href="https://git-scm.com/download下载然后按默认选项安装即可。" target="_blank" rel="noopener">https://git-scm.com/download下载然后按默认选项安装即可。</a></p></li><li><p>安装完成后，右键看到 Git Bash Here，证明Git安装成功了</p><p><img src="/../git%E6%80%BB%E7%BB%93/Snipaste_2023-01-18_17-34-05.png" alt=""></p></li><li><p>安装完成，需要设置如下操作，在命令行输入：</p><ul><li>git config –global user.name “<span style="color: red">Your Name</span>“</li><li>git config –global user.name “<span style="color: red">Your Email</span>“</li><li>git config user.name     用于查看配置的姓名</li><li>git config user.email     用于查看配置的邮箱</li></ul></li></ul><h3 id="2-git的三区"><a href="#2-git的三区" class="headerlink" title="2.git的三区"></a>2.git的三区</h3><ul><li>工作区（working Directory）</li><li>暂存区（Stage）</li><li>版本区（Repository）<ul><li>第一步： git add xxx    把文件添加带暂存区</li><li>第二步：git commit -m ‘xxxx’     把暂存区所有内容提交到当前版本库</li></ul></li></ul><h3 id="3-创建版本库"><a href="#3-创建版本库" class="headerlink" title="3.创建版本库"></a>3.创建版本库</h3><ol><li><p>git init命令：初始化版本库</p><ul><li>目录上会多一个.git文件夹，这个文件夹是Git用来跟踪管理版本库的，不要修改和删除里面的内容。</li></ul></li><li><p>git add x.xx命令：添加指定文件到暂存区中</p><ul><li>没有任何提示，代表提交成功</li><li>若未初始化，会提示  <span style="color: red">fatal: Not a git repository (or any of the parent directories): .git</span></li><li>失败会提示fatal: <span style="color: red">pathspec ‘x.txt’ did not match any files</span></li><li>可能会出现警告：<span style="color: red">warning: LF will be replaced by CRLF in xxxxx</span><ul><li>原因： linux和window的换行符不一致导致的</li><li>解决方式：执行命令git config –global core.autocrlf false</li></ul></li></ul></li><li><p>git commit -m ‘xxxx’命令：提交所有暂存区的文件到版本区</p><ul><li><p>提交成功如下图</p><p><img src="/../../git%E6%80%BB%E7%BB%93/commitsuccess-1674036704980-2.png" alt="提交成功"></p></li></ul></li></ol><blockquote><p>备注：如何查看文件有无添加成功</p><p>git status</p><ul><li>红色表示在工作区</li><li>绿色表示在暂存区</li><li>没有任何显示表示在工作区</li></ul></blockquote><h3 id="4-差异对比"><a href="#4-差异对比" class="headerlink" title="4.差异对比"></a>4.差异对比</h3><ul><li>git diff：比较暂存区和工作区</li><li>git diff –cached：比较版本去和暂存区</li><li>git diff master：比较版本去和工作区</li></ul><h3 id="5-日志和版本号"><a href="#5-日志和版本号" class="headerlink" title="5.日志和版本号"></a>5.日志和版本号</h3><ul><li><p>git log：显示从最近到最远的所有提交日志</p></li><li><p>git reflog：显示每次提交的commit id</p></li></ul><h3 id="6-版本回退-版本穿梭-版本撤销"><a href="#6-版本回退-版本穿梭-版本撤销" class="headerlink" title="6.版本回退 + 版本穿梭 + 版本撤销"></a>6.版本回退 + 版本穿梭 + 版本撤销</h3><ul><li>git reset –hard HEAD^  版本回退（^回退一次，^^回退两次）</li><li>git reset –hard 版本号  回退到指定的版本</li><li>git reset HEAD          用版本库种的文件去替换暂存区的全部文件</li><li>git checkout – x.txt   用暂存区的文件替换工作区的指定文件<span style="color: red">（危险）</span></li><li>git checkout HEAD x.txt 用版本区的文件替换暂存区和工作区的文件<span style="color: red">(危险)</span></li><li>git rm –cached x.txt   从暂存区删除文件</li></ul><h3 id="7-删除文件"><a href="#7-删除文件" class="headerlink" title="7.删除文件"></a>7.删除文件</h3><p>git rm x.txt     删除文件<br>git rm -r xxx    删除文件夹</p><blockquote><p>备注：上述两个操作必须经过git管理才可以删除<br>删除文件夹操作文件夹必须有文件，才可以删除<br>上述删除和直接系统删除不一样，git删除必须add和commit，系统删除则不用<br>rm -r xxx  linux删除文件</p></blockquote><h3 id="8-分支"><a href="#8-分支" class="headerlink" title="8.分支"></a>8.分支</h3><ul><li>git checkout -b dev                 创建dev分支，并且切换到dev分支</li><li>git branch                          查看当前分支</li><li>git checkout master                 切换分支</li><li>git merge dev                       合并dev分支到当前分支</li><li>git branch -d dev                   删除指定分支</li><li>git diff branch1 branch2            显示出两个分支之间所有的差异的文件的详细差异</li><li>git diff branch1 branch2 –stat     显示两个分支之间所有差异的文件列表</li><li>git diff branch1 branch2 xxx        显示指定文件的详细差异</li></ul><h3 id="9-版本冲突"><a href="#9-版本冲突" class="headerlink" title="9.版本冲突"></a>9.版本冲突</h3><blockquote><p>合并分支时，如果在同一个文件，在同一个地方，都修改了或新增内容会引起版本冲突</p></blockquote><h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><h3 id="1-GitHub是什么"><a href="#1-GitHub是什么" class="headerlink" title="1.GitHub是什么"></a>1.GitHub是什么</h3><ul><li>GitHub是一个Git项目托管网站</li></ul><h3 id="2-GitHub远程仓库的使用"><a href="#2-GitHub远程仓库的使用" class="headerlink" title="2.GitHub远程仓库的使用"></a>2.GitHub远程仓库的使用</h3><h4 id="2-1场景一（关联）：本地有仓库，要和远程仓库做关联"><a href="#2-1场景一（关联）：本地有仓库，要和远程仓库做关联" class="headerlink" title="2.1场景一（关联）：本地有仓库，要和远程仓库做关联"></a>2.1场景一（关联）：本地有仓库，要和远程仓库做关联</h4><ul><li>git init</li><li>git add .</li><li>git commit -m ‘first commit’</li><li>在github或者gitee上创建一个远程仓库</li><li>git remote add origin <a href="https://github.com/xxxx" target="_blank" rel="noopener">https://github.com/xxxx</a>    <span style="color: red">只有origin可以修改</span></li></ul><blockquote><p>备注：如果关联错了，解决方法如下<br>暴力解决：删除.git文件夹，重新建立本地仓库<br>优雅解决：git remote remove origin，在重新关联</p></blockquote><h4 id="2-2场景二（推送）：本地有仓库有内容，远程库为空，要推送给远程库"><a href="#2-2场景二（推送）：本地有仓库有内容，远程库为空，要推送给远程库" class="headerlink" title="2.2场景二（推送）：本地有仓库有内容，远程库为空，要推送给远程库"></a>2.2场景二（推送）：本地有仓库有内容，远程库为空，要推送给远程库</h4><ul><li>git push -u origin master  (首次加-u)</li><li>根据提示输入用户名和密码</li><li>我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送到远程新的master分支，还会把本master<br>分支和远程的master分支关联起来，在以后的推送时可以简化命令git push origin master。</li></ul><blockquote><p>备注：正常情况下，成功推送一次后，电脑会记住和账号与密码，下次推送时不会再提示输入。若在电脑不能够自动记住github的账<br>  户和密码，需执行以下命令解决：git config –global credential.helper store</p></blockquote><h4 id="2-3场景三（拉取）：本地有仓库，要获取远程库新增或修改的东西"><a href="#2-3场景三（拉取）：本地有仓库，要获取远程库新增或修改的东西" class="headerlink" title="2.3场景三（拉取）：本地有仓库，要获取远程库新增或修改的东西"></a>2.3场景三（拉取）：本地有仓库，要获取远程库新增或修改的东西</h4><ul><li>第一种拉取方式： git pull origin master<ul><li>将远程的master分支上的代码版本复制/合并到本地master上</li></ul></li><li>第二种拉去方式：git fetch origin master:tmp<ul><li>新建一个tmp分支，将远程的master分支代码复制到tmp分支上，不会自动合并</li></ul></li></ul><h4 id="2-4场景四（克隆）：本地没有仓库，要获取一个完整的远程库"><a href="#2-4场景四（克隆）：本地没有仓库，要获取一个完整的远程库" class="headerlink" title="2.4场景四（克隆）：本地没有仓库，要获取一个完整的远程库"></a>2.4场景四（克隆）：本地没有仓库，要获取一个完整的远程库</h4><blockquote><p>备注：只有第一次获取远程库的时候才需要克隆</p><ul><li>git clone <a href="https://github.com/xxx.git" target="_blank" rel="noopener">https://github.com/xxx.git</a></li></ul></blockquote><h4 id="2-5场景五（带有分支的上述操作）"><a href="#2-5场景五（带有分支的上述操作）" class="headerlink" title="2.5场景五（带有分支的上述操作）"></a>2.5场景五（带有分支的上述操作）</h4><blockquote><p>获取的是所有分支的代码，git branch看不到，但是可以切换</p><ul><li>git clone -b dev https:..github.com/xxx.git   克隆dev分支代码</li></ul></blockquote><h3 id="git设置忽略文件"><a href="#git设置忽略文件" class="headerlink" title="git设置忽略文件"></a>git设置忽略文件</h3><p>-创建一个 .gitgnore 文件</p><ul><li>.idea  忽略所有.idea文件</li><li>*.idea 忽略所有以.idea为后缀的文件</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> git 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决跨域</title>
      <link href="/2023/01/18/jie-jue-kua-yu/"/>
      <url>/2023/01/18/jie-jue-kua-yu/</url>
      
        <content type="html"><![CDATA[<h3 id="1-为什么会有跨域这个问题？"><a href="#1-为什么会有跨域这个问题？" class="headerlink" title="1.为什么会有跨域这个问题？"></a>1.为什么会有跨域这个问题？</h3><blockquote><p>原因是浏览器为了安全，而采用的同源策略（Same origin policy）</p></blockquote><h3 id="2-什么是同源策略？"><a href="#2-什么是同源策略？" class="headerlink" title="2.什么是同源策略？"></a>2.什么是同源策略？</h3><pre><code>1. 同源策略是由Netscape提出的一个著名的安全策略，现在所有支持JavaScript 的浏览器都会使用这个策略。2. Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。3. 所谓同源是指：协议，域名（IP），端口必须要完全相同   即：协议、域名（IP）、端口都相同，才能算是在同一个域里。</code></pre><p>备注：规则举例如下(假设已有网站地址为：<a href="http://study.cn" target="_blank" rel="noopener">http://study.cn</a>)<br><img src="https://s2.ax1x.com/2019/01/26/knAIit.png" alt="Alt text"></p><h3 id="3-没有同源策略的危险场景："><a href="#3-没有同源策略的危险场景：" class="headerlink" title="3.没有同源策略的危险场景："></a>3.没有同源策略的危险场景：</h3><p>危险场景：</p><blockquote><p>有一天你刚睡醒，收到一封邮件，说是你的银行账号有风险，赶紧点进<a href="http://www.yinghang.com改密码。你着急的赶紧点进去，还是熟悉的银行登录界面，你果断输入你的账号密码，登录进去看看钱有没有少了，睡眼朦胧的你没看清楚，平时访问的银行网站是www.yinhang.com，而现在访问的是www.yinghang.com，随后你来了一条短信，钱没了，这个钓鱼网站做了什么呢？大概是如下思路：" target="_blank" rel="noopener">www.yinghang.com改密码。你着急的赶紧点进去，还是熟悉的银行登录界面，你果断输入你的账号密码，登录进去看看钱有没有少了，睡眼朦胧的你没看清楚，平时访问的银行网站是www.yinhang.com，而现在访问的是www.yinghang.com，随后你来了一条短信，钱没了，这个钓鱼网站做了什么呢？大概是如下思路：</a></p></blockquote><pre><code>&lt;iframe id="baidu" src="https://www.baidu.com"&gt;&lt;/iframe&gt;&lt;script type="text/javascript"&gt;  const iframe = window.frames['baidu']  const inputNode = iframe.document.getElementById('输入敏感信息的input的id')  console.log(inputNode.value)&lt;/script&gt;</code></pre><h3 id="3-非同源受到哪些限制？"><a href="#3-非同源受到哪些限制？" class="headerlink" title="3.非同源受到哪些限制？"></a>3.非同源受到哪些限制？</h3><pre><code>1. Cookie不能读取；2. DOM无法获得；3. Ajax请求不能发送</code></pre><h3 id="4-如何在开发中解决跨域问题："><a href="#4-如何在开发中解决跨域问题：" class="headerlink" title="4.如何在开发中解决跨域问题："></a>4.如何在开发中解决跨域问题：</h3><p><strong>1.JSONP解决发送请求跨域问题：</strong></p><blockquote><p>要明确的是：JSONP不是一种技术，而是程序员“智慧的结晶”（利用了标签请求资源不受同源策略限制的特点）<br>JSONP需要前后端人员互相配合。</p></blockquote><p>前端页面写法：</p><pre><code>    &lt;body&gt;      &lt;button id="btn"&gt;按钮&lt;/button&gt;      &lt;script type="text/javascript"&gt;        var btn = document.getElementById('btn');        btn.onclick = function () {          //1. 创建一个script标签          var script = document.createElement('script');          //2. 设置回调函数          window.getData = function (data) {            console.log(data);//拿到数据          }          //3. 设置script标签src属性，填写跨域请求的地址          script.src = 'http://localhost:3000/jsonp?callback=getData';          //4. 将script标签添加到body中生效          document.body.appendChild(script);          //5.不影响整体DOM结构，删除script标签          document.body.removeChild(script);        }      &lt;/script&gt;    &lt;/body&gt;</code></pre><p>后端写法：</p><pre><code>app.get('/jsonp', (req, res) =&gt; {  //解构赋值获取请求参数  const {callback} = req.query  //去数据库查找对应数据  const data = [{name: 'tom', age: 18}, {name: 'jerry', age: 20}];  res.send(callback + '(' + JSON.stringify(data) + ')');})</code></pre><p><strong>2.后台配置cors解决跨域</strong></p><pre><code>以Node为例：res.set('Access-Control-Allow-Origin', 'http://localhost:63342');</code></pre><p><strong>3.使用代理服务器</strong></p><pre><code>例如：nginx等</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 跨域 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
